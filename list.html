<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8" />
<link rel="stylesheet" href="green.css" media="all" />
<title>リスト</title>
</head>
<body>
<h1>リスト</h1>
<div class="right">
<p>「見方によっては関数プログラミングはリスト処理と同義である」<br />
Jeremy Gibbons<br />
関数プログラミングの楽しみ</p>
</div>
<p>この章では、リストに関する基本的な関数 map、(++)、concat、および concatMap を復習します。なぜこれらの関数を復習するかというと、map と concatMap は Monad を理解するために重要であり、(++) と concat は concatMap を定義するために必要だからです。</p>
<h2>写像 (map)</h2>
<p>再帰を使えば、リストを操作する関数はなんでも書けます。しかし再帰は用途が広いので、再帰を使ったコードは意図が不明瞭になりがちです。</p>
<p>意図を明確にするには、再帰よりも用途が限定された関数を使うべきです。畳み込み関数 foldr は、再帰よりも用途が限定された関数です。map や filter の用途は、foldr よりもさらに限定されています。</p>
<p>そこでリストを扱うときは、まず最初に map や filter が利用できないか考え、ダメなら foldr の使用を検討し、最終手段として再帰を用いるのがよい習慣です。</p>
<p>map は、第一引数である関数を第二引数であるリストの中身に対して適用する関数です。以下に利用例を示します。</p>
<pre>
&gt; map (+1) [1..5]
[2,3,4,5,6]
</pre>
<p>文献(Haskell98)では、map 自体は再帰を使って定義しています。</p>
<pre>
map :: (a -&gt; b) -&gt; [a] -&gt; [b]
map _ []     = []
map f (x:xs) = f x : map f xs
</pre>
<p>ただし、map はfoldr を使っても定義可能です。(foldr は、再帰を使って定義されています。)</p>
<pre>
map :: (a -&gt; b) -&gt; [a] -&gt; [b]
map f = foldr (\x xs -&gt; f x : xs) []
</pre>
<p>ここで、関数 f :: a -&gt; b を map の第一引数に部分適用してみましょう。</p>
<pre>
f :: a -&gt; b
map f :: [a] -&gt; [b]
</pre>
<p>型をよく見比べて下さい。型 a から型 b を返す関数が、[a] から [b] を返す関数へ変換されたことが分かります。このことを「map は関数 f をリストの世界に持ち上げる(lift)」と表現します。慣習として、通常の型よりも、リストの世界の方が上にあると考えるからです。</p>
<p>写像はリストに限った手法ではなく、さまざまなデータ型にも適用できます。そこで、写像関数 API とする型クラスが定義されています。その型クラスの名前を Functor といいます。</p>
<p>Functor が提供する写像関数の名前は、fmap といいます。</p>
<pre>
class Functor m where
    fmap :: (a -&gt; b) -&gt; f a -&gt; f b
</pre>
<p>もちろんリストは Functor のインスタンスです。リストは Functor のインスタンスであり、その実装の一例は以下のようになります。</p>
<pre>
instance Functor [] where
    fmap = map
</pre>
<p>fmap は、二項演算子として使うとコードの見通しがよくなります。ここでは、上記の簡単な例を書き換えてみましょう。</p>
<pre>
&gt; (+1) `fmap` [1..5]
[2,3,4,5,6]
</pre>
<p>Control.Applicative モジュールでは、fmap の別名として (&lt;$&gt;) を定義していますので、さらに読みやすくなります。</p>
<pre>
&gt; :m Control.Applicative
&gt; (+1) &lt;$&gt; [1..5]
[2,3,4,5,6]
</pre>
<p>(&lt;$&gt;)が、関数適用の二項演算子($)と似ているところがポイントです。(&lt;$&gt;)は、特殊な関数適用なのです。これ以降、本書では fmap の代わりに (&lt;$&gt;) を使います。</p>
<p>map には、リストの大きさを変えないという性質があります。一般化された (&lt;$&gt;) も、その性質を持っています。すなわち、Functor を「物を入れる箱」と見なせば、(&lt;$&gt;)は箱の大きさは変えず、中身の値だけを変化させます。</p>
<p>この性質は、以下のように表現されます。</p>
<pre>
f &lt;$&gt; g &lt;$&gt; m = (f . g) &lt;$&gt; m
</pre>
<p>(&lt;$&gt;) に慣れていない内は、箱をリストに限定した map で考える方が分かりやすいかもしれません。</p>
<pre>
map f (map g m) = map (f . g) m
</pre>
<p>例を挙げてみましょう。文字列中のアルファベットを次のアルファベットに変換してみます。これには、文字を ord で一旦数値に直し、1 を加えた後、文字 chr で文字に戻すことになります。</p>
<pre>
&gt; :m Data.Char
&gt; map chr $ map (+1) $ map ord ['a'..'c']
→ &quot;bcd&quot;
</pre>
<p>上記の法則が言っているのは、これら三つの map を一つにまとめられるということです。</p>
<pre>
&gt; :m Data.Char
&gt; map (chr . (+1) . ord) ['a'..'c']
→ &quot;bcd&quot;
</pre>
<p>Haskell のコンパイラーが素朴な実装であれば、map を一つにまとめた方がプログラムが速くなります。なぜなら、中間のリストを生成しないからです(図xxx)。この手法を融合(fusion)と言います。</p>
<p>hlint というプログラムを使えば、融合変換を施せる場所を指摘してくれます。なお GHC では、融合変換を自動的にやってくれます。</p>
<p>融合変換に慣れたところで、(&lt;$&gt;) を使って最後の例の見た目を変えてみましょう。</p>
<pre>
&gt; :m Control.Applicative Data.Char
&gt; chr . (+1) . ord &lt;$&gt; ['a'..'c']
→ &quot;bcd&quot;
</pre>
<p>(&lt;$&gt;) よりも(.)の方が結合力が強いので、括弧が不要になります。</p>
<h2>追加 (++)</h2>
<p>(++) は、第一式引数を第二引数へ追加する関数です。</p>
<pre>
&gt; &quot;Hello, &quot; ++ &quot;World!&quot;
→ &quot;Hello, World!&quot;
</pre>
<p>文献(Haskell98)では、(++)を再帰を用いて定義しています。</p>
<pre>
(++) :: [a] -&gt; [a] -&gt; [a]
[]     ++ ys = ys
(x:xs) ++ ys = x : (xs ++ ys)
</pre>
<p>リストの性質を活かして、コピーを取るのは第一引数のみであり、第二引数は共有されるのが分かります(図xxx)。</p>
<p>(++) は foldr を用いて、以下のように定義することもできます。</p>
<pre>
(++) :: [a] -&gt; [a] -&gt; [a]
xs ++ ys = foldr (:) ys xs
</pre>
<p>foldr に慣れている人にとっては、こちらの定義の方がよいでしょう。なぜなら、(++) は右から畳み込んだ方が効率がよいと主張しているのが分かるからです。</p>
<p>第xxx章で、MonadPlus という型クラスの API として、mplus が出てきます。実は、リストの mplus は (++) そのものです。</p>
<p>(xxx 疑問 ++ は再帰で、concat は foldr。なぜ？)</p>
<h2>連結 (concat)</h2>
<p>concat は、リストのリストを取り、リストを返す関数です。以下に使い方の例を示します。</p>
<pre>
&gt; concat [[1],[2,3],[4,5,6]]
→ [1,2,3,4,5,6]
</pre>
<p>concat を再帰を用いて定義すると以下のようになります。</p>
<pre>
concat :: [[a]] -&gt; [a]
concat [] = []
concat (xs:xss) = xs ++ concat xss
</pre>
<p>なお、文献(Haskell98)では、concat を foldr を用いて以下のように定義しています。</p>
<pre>
concat :: [[a]] -&gt; [a]
concat = foldr (++) []
</pre>
<h2>写像して連結 (concatMap)</h2>
<p>concatMap は、concat と map を合成した関数です。</p>
<pre>
concatMap   :: (a -&gt; [b]) -&gt; [a] -&gt; [b]
concatMap f =  concat . map f
</pre>
<p>concatMap 動作を段階を踏んで理解しましょう。まず、次のような数値のリストのリストに filter even を map してみます。</p>
<pre>
&gt; map (filter even) [[1],[2,3],[4,5,6]]
[[],[2],[4,6]]
</pre>
<p>偶数のリストのリストできました。concat を使うと、内側のリストを潰すことができます。</p>
<pre>
&gt; concat $ map (filter even) [[1],[2,3],[4,5,6]]
[2,4,6]
</pre>
<p>これを同時にやるのが、concatMap です。</p>
<pre>
&gt; concatMap (filter even) [[1],[2,3],[4,5,6]]
[2,4,6]
</pre>
<p>この例では、concatMap の嬉しさは伝わらないでしょう。concatMap が活躍するのは、リスト内包表記やリストを Monad として使ったときです。実は、concatMap の第一式数と第二引数を入れ替えると、リストの (&gt;&gt;=) になります。リストの (&gt;&gt;=) を定義する例を以下に示します。</p>
<pre>
listBind :: [a] -&gt; (a -&gt; [b]) -&gt; [b]
listBind = flip concatMap

instance Monad [] where
    (&gt;&gt;=) = listBind
</pre>
<p>型が分かるように、まず listBind という関数を定義して、それをリストの (&gt;&gt;=) に指定しています。なお、文献(Haskell98) では、以下のように定義されています。</p>
<pre>
instance Monad [] where
    f &gt;&gt;= m = concat (map f m)
</pre>
<p>リストの (&gt;&gt;=) がどういう役割を果たすのかは、第xxx章で明らかにします。</p>

<hr />
<p>
著作権は山本和彦に属します。意見、質問、議論などは、<a href="http://github.com/kazu-yamamoto/monad/issues">github の Issues</a> へ。
</p>
</body>
</html>
