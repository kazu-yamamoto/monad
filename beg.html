<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8" />
<link rel="stylesheet" href="green.css" media="all" />
<title>はじめに</title>
</head>
<body>
<h1>はじめに</h1>
<p>Haskell を学ぶ人にとって、最大の障壁は Monad だと言われています。私も Monad を理解するのに大変苦労しました。分かってしまえば簡単なことなのに、どうしてあんなに苦労したのでしょう？ 分かりやすく包括的なチュートリアルがなかったことが一因ではないかと思います。そこで、他の人が同じような苦労をしないですむよう、この本を書きました。</p>
<p>私の信念はこうです：「リストの関数 map を理解できる人は、 Monad も理解できる」</p>
<p>Monad の習得に四苦八苦している人は、まさかと思うかもしれませが、本当です。理由を理屈っぽく説明すると次のようになります。</p>
<ul>
<li>型クラス Monad は、型クラス Functor の強化版である</li>
<li>型クラス Functor は、関数 fmap を提供する型の集合である</li>
<li>型クラス Functor の代表例はリストであり、リストの fmap とは map のことである</li>
</ul>
<p>つまり、Haskell を学んだことがある人なら誰でも知っているリストや map を強力にしたのが Monad です。こう言われれば、自分にも Monad が理解できそうな気にならないでしょうか？</p>
<p>理屈ばかり並べられてもイメージが湧かないという人のために、 Monad を見えるものに例えましょう。 Monad とは、おもちゃのブロックです。おもちゃのブロックで自動車を組み立てる場面を想像して下さい。ブロックという部品をいくつかくっつけ、自動車が完成したら走らせて遊びます。それがどうしたと思われるかもしれませんが、Monad を使ったプログラミングは、驚くほどこの例えに似ています。</p>
<p>Monad とは、Haskell に組み込まれているマイクロ・プログラミング言語です。 型クラス Monad に属する型のデータが部品です。その部品を同種の部品と演算子 (&gt;&gt;=) でくっつけ、マイクロ・プログラムが完成したら、その全体を走らせるのです。</p>
<p>ある会社が販売するブロックが、他社のブロックとはくっつかないように、種類の異なる Monad はくっつきません。たとえば、Maybe と IO はくっつきません。Maybe は Maybe と、IO は IO とのみくっつけられます。(IO もデータですよ！) 本書を読み進めると、プログラムの安全性を確保するために、これが大変役立っていることが分かるでしょう。</p>
<h2>Monadに関する誤解</h2>
<p>世の中は、Haskell や Monad に関する誤った情報であふれています。間違った知識に影響されたままで本書を読み進めてほしくないので、ここで典型的な誤解を解いておきましょう。</p>
<dl>
<dt>Haskellには副作用がない。</dt>
<dd>その後にはたいてい、副作用がないのにどうしてゲームを作れるのだろうという疑問が続きます。はっきりさせておきましょう。Haskell には命令型言語のプログラマーが言うところの副作用はあります。副作用があるからゲームを作れるのは不思議ではありません。ただし、副作用を生じさせる仕組みは、命令型言語のそれとはかなり異なっています。Haskell の副作用の値を表す型は IO です。副作用を引き起こす可能性のある関数は IO a の値を返し、純粋な関数はけっして IO a を返しません。この仕組みのおかげで、副作用のある関数とない関数を安全に分離できます。詳しくは、xxx を参照して下さい。</dd>
<dt>Haskellでは遅延評価なので関数の動作順序が決まらない。動作順序を決めるのが Monad である。</dt>
<dd>Monad であっても、 Monad でない関数であっても、動作順序は決まっています。ただし、どちらも記述されている順番が動作順序になるとは限りません。しかし IO Monad は、記述順に動作することが保証されています。 Monad でなくても記述順に動作する場合もあります。例えば、真理値を論理演算とともに並べれば、必ず左から右へ評価されていきます。詳しくは、xxx を参照して下さい。</dd>
<dt>圏論が分からなければ、 Monad も理解できない</dt>
<dd>そんなことはありません！ Monad が、数学の一分野である圏論から発祥していて、数学の理論にしっかりと支えられていることは事実です。しかし、 Monad でプログラミングする人が、圏論を理解している必要はありません。私だって理解してないのですから。</dd>
</dl>
<p>さまざまな風評にも関わらず、Monad は単に型クラスの1つにすぎません。つまり、共通の API (クラスメソッド)を提供するクラスの集合です。たとえば、Num クラスに属する Int や Float は、共通の API として演算子(+)や(-)を提供します。Num クラスがすぐに理解できるのは、利用者に数学の素養があるためと、Int の (+) も Float の (+) も同じような振る舞いを示すからでしょう。</p>
<p>Monad は、共通の API として return と (&gt;&gt;=) を提供します。Monad が分かりにくいのは、(&gt;&gt;=) になじみがないことと、Monad のインスタンスである Maybe や State、IO などの (&gt;&gt;=) が、それぞれ独自の振る舞いを示すからです。結局、 Monad を理解するには、たくさんの実例を見て動かす必要があります。本書では、簡潔で分かりやすい例をたくさん示すように努めました。</p>
<h2>対象とする読者</h2>
<p>この本の想定する読者は、Haskellを勉強したけれど Monad の理解で行き詰まっている人です。Haskellの知識としては、「プログラミングHaskell」{PIH}に書かれている程度の内容を理解していることを前提としています。</p>
<p>本書の説明には、命令型言語のプログラマーが使う用語を用います。純粋関数型言語のプログラマーや圏論の人達が使う用語の意味とは異なる可能性があるので注意して下さい。</p>
<h2>目的</h2>
<p>本書の目的は二つあります。一つは、Monad を理解すること。もう一つは、なるべく Monad を使わないスタイルを身につけることです。これは、再帰をよく理解すると、関数定義になるべく再帰を使わなくなるのと似ています。</p>
<p>本書では、三つの型クラスに焦点を当てます。その型クラスとは、Functor、Applicative、そして Monad です。それぞれの定義は、以下の通りです。</p>
<pre>
class Functor m where
    fmap :: (a -&gt; b) -&gt; m a -&gt; m b
</pre>
<pre>
class Functor m =&gt; Applicative m where
    pure :: a -&gt; m a  -- 実は return と同じ
    (&lt;*&gt;) :: m (a -&gt; b) -&gt; m a -&gt; m b
</pre>
<pre>
class Monad m where
    return :: a -&gt; m a
    (&gt;&gt;=) :: m a -&gt; (a -&gt; m b) -&gt; m b
</pre>
<p>Applicative は、Functor のサブクラスです。また、歴史的な経緯により Monad は Applicative のサブクラスとしては定義されていませんが、以下のようにサブクラスだと考えて構いません。</p>
<pre>
class Applicative m =&gt; Monad m where
    (&gt;&gt;=) :: m a -&gt; (a -&gt; m b) -&gt; m b
</pre>
<p>Functor、Applicative、Monad の順に特殊になっていき、それに従って力が強くなります。たとえば、Applicative の力で解ける問題に、Monad を使う必要はありません。問題に対して適切な力の型クラスを使えば、コードの見通しがよくなるとともに安全になります。</p>
<p>型を見れば分かるように、pure と return は、本当は同じ関数であるべきです。それが、二番目の Monad の定義に return を含めなかった理由です。本書では、pure を極力使わずに、ほとんどの場合で return と同一視します。また、fmap もなるべく使わずに、ほとんどの場合で別名である (&lt;$&gt;) を使用します。</p>
<p>上記をまとめると、本書で扱う三つの型クラスは以下のようになります。</p>
<pre>
class Functor m where
    (&lt;$&gt;) :: (a -&gt; b) -&gt; m a -&gt; m b
</pre>
<pre>
class Functor m =&gt; Applicative m where
    return :: a -&gt; m a
    (&lt;*&gt;) :: m (a -&gt; b) -&gt; m a -&gt; m b
</pre>
<pre>
class Applicative m =&gt; Monad m where
    (&gt;&gt;=) :: m a -&gt; (a -&gt; m b) -&gt; m b
</pre>
<h2>凡例</h2>
<p>Haskell のインタープリターとしては、ghci の利用を仮定します。ghci のプロンプトには &quot;&gt; &quot; を用います。右矢印（→）の右側は、評価結果を表します。</p>
<pre>
&gt; :m Data.Char
&gt; map ord ['a'..'c']
→ [97,98,99]
</pre>

<hr />
<p>
著作権は山本和彦に属します。意見、質問、議論などは、<a href="http://github.com/kazu-yamamoto/monad/issues">github の Issues</a> へ。
</p>
</body>
</html>
