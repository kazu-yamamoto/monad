* はじめに

Haskell を学ぶ人にとって、最大の障壁は Monad だと言われています。私も Monad を理解するのに大変苦労しました。分かってしまえば簡単なことなのに、どうしてあんなに苦労したのでしょう？ それは、分かりやすく包括的なチュートリアルがなかったからです。そこで、他の人が同じような苦労をしないですむよう、この本を書きました。

私の信念はこうです：「リストの関数 map が理解できる人は、 Monad も理解できる」

 Monad の習得に四苦八苦している人は、まさかと思うかもしれません。しかし、本当です。理由を理屈っぽく説明すると次のようになります。

-型クラス Monad は、型クラス Functor の強化版である
-型クラス Functor は、関数 fmap を提供する型の集合である
-型クラス Functor の代表的なインスタンスはリストであり、リストの fmap とは map のことである

つまり、Haskell を学んだことがある人なら誰でも知っているリストや map を強力にしたのが Monad です。こう言われれば、自分にも Monad が理解できそうな気にならないでしょうか？

理屈ばかり並べられてもイメージが湧かないという人のために、 Monad を見えるものに例えましょう。 Monad とは、おもちゃのブロックです。おもちゃのブロックで自動車を組み立てる場面を想像して下さい。ブロックという部品をいくつかくっつけ、自動車が完成したら走らせて遊びます。それがどうしたと思われるかもしれませんが、Monad を使ったプログラミングは、驚くほどこの例えに似ています。

Monad とは、Haskell に組み込まれているマイクロ・プログラミング言語です。 型クラス Monad に属する型のデータが部品です。その部品を同種の部品と演算子 (>>=) でくっつけ、マイクロ・プログラムが完成したら、その全体を走らせるのです。

ある会社が販売するブロックが、他社のブロックとはくっつかないように、種類の異なる Monad はくっつきません。たとえば、Maybe と IO はくっつきません。Maybe は Maybe と、IO は IO とのみくっつけられます。本書を読み進めると、プログラムの安全性を確保するために、これが大変役立っていることが分かるでしょう。

世の中は、Haskell や Monad に関する誤った情報であふれています。間違った知識に影響されたままで本書を読み進めてほしくないので、ここで典型的な誤解を解いておきましょう。

?Haskellには副作用がない。
!その後にはたいてい、副作用がないのにどうしてゲームを作れるのだろうという疑問が続きます。はっきりさせておきましょう。Haskell には副作用があります。副作用があるからゲームを作れるのは不思議ではありません。Haskell の副作用を表す型は IO です。副作用がある関数は IO a の値を返し、純粋な関数はけっして IO a を返しません。この仕組みのおかげで、副作用のある関数とない関数を安全に分離できます。詳しくは、xxx を参照して下さい。
?Haskellでは遅延評価なので関数の動作順序が決まらない。動作順序を決めるのが Monad である。
! Monad であっても、 Monad でない関数であっても、動作順序は決まっています。ただし、どちらも記述されている順番が動作順序になるとは限りません。しかし IO Monad は、記述順に動作することが保証されています。 Monad でなくても記述順に動作する場合もあります。例えば、真理値を論理演算とともに並べれば、必ず左から右へ評価されていきます。詳しくは、xxx を参照して下さい。
?圏論が分からなければ、 Monad も理解できない
!そんなことはありません！  Monad が、数学の一分野である圏論から発祥していて、数学の理論にしっかりと支えられていることは事実です。しかし、 Monad でプログラミングする人が、圏論を理解している必要はありません。私だって理解してないのですから。

さまざまな風評にも関わらず、Monad は単に型クラスの1つにすぎません。つまり、共通の API (クラスメソッド)を提供するクラスの集合です。たとえば、Num クラスに属する Int や Float は、共通の API として演算子(+)や(-)を提供します。Num クラスがすぐに理解できるのは、利用者に数学の素養があるためと、Int の (+) も Float の (+) も同じような振る舞いを示すからでしょう。

Monad は、共通の API として return と (>>=) を提供します。Monad が分かりにくいのは、(>>=) になじみがないことと、Monad のインスタンスである Maybe や State、IO などの (>>=) が、それぞれ独自の振る舞いを示すからです。結局、 Monad を理解するには、たくさんの実例を見て動かす必要があります。本書では、簡潔で分かりやすい例をたくさん示すように努めました。

**用語

>|
Data.Char> map ord ['a'..'c']
→ [97,98,99]
|<

:m Data.Char を実行する

右矢印（→）の右側は、結果を表す

